"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MULTILINE_PROPERTY = exports.CONSIST_NEWLINE = exports.NO_BLANK_BETWEEN = exports.MUST_SPLIT_TOO_LONG = exports.MUST_NOT_SPLIT = exports.MUST_SPLIT = void 0;
var MAX_COUNT = 2;
var MAX_REST_COUNT = 1;
var MAX_LENGTH = Infinity;
var CONSISTENT = false;
var ALLOW_ALL_PROPERTIES_ON_SAME_LINE = false;
exports.MUST_SPLIT = 'mustSplit';
exports.MUST_NOT_SPLIT = 'mustNotSplit';
exports.MUST_SPLIT_TOO_LONG = 'mustSplitTooLong';
exports.NO_BLANK_BETWEEN = 'noBlankBetween';
exports.CONSIST_NEWLINE = 'consistNewline';
exports.MULTILINE_PROPERTY = 'multilineProperty';
function isRestElement(item) {
    return item.type === 'RestElement'
        // for babel-eslint compatibility
        || item.type === 'ExperimentalRestProperty';
}
function isSameLine(first, last) {
    return first.loc.end.line === last.loc.start.line;
}
function getPropertyString(source, item, multiLine, isLast) {
    var _a, _b;
    if (isLast === void 0) { isLast = false; }
    var originalText = source.getText(item);
    if (isRestElement(item)) {
        if (item.argument.type === 'Identifier') {
            return "..." + item.argument.name;
        }
        return originalText;
    }
    var value = item.value, key = item.key;
    var endString = ',';
    if (isLast) {
        endString = '';
    }
    else if (multiLine) {
        endString += '\n';
    }
    if ((key.type !== 'Identifier' && key.type !== 'Literal') || (value.type !== 'Identifier'
        && value.type !== 'AssignmentPattern'
        && value.type !== 'ObjectPattern')) {
        return originalText;
    }
    var valueString = key.type === 'Identifier'
        ? key.name
        : (_a = key.raw) !== null && _a !== void 0 ? _a : '';
    if (value.type === 'Identifier') {
        if (item.shorthand) {
            return valueString + endString;
        }
        return valueString + ": " + value.name + endString;
    }
    if (value.type === 'ObjectPattern') {
        return valueString + ": " + source.getText(value) + endString;
    }
    if (value.left.type !== 'Identifier' && value.left.type !== 'ObjectPattern') {
        return originalText;
    }
    if (value.left.type === 'ObjectPattern') {
        valueString += ": " + source.getText(value.left);
    }
    else if (!item.shorthand) {
        valueString += ": " + value.left.name;
    }
    valueString += ' = ';
    if (value.right.type === 'Identifier') {
        valueString += value.right.name;
    }
    else if (value.right.type === 'Literal') {
        valueString += (_b = value.right.raw) !== null && _b !== void 0 ? _b : '';
    }
    else {
        valueString += source.getText(value.right);
    }
    return valueString + endString;
}
function getFixer(source, node, multiLine) {
    if (multiLine === void 0) { multiLine = true; }
    return function (fixer) {
        var properties = node.properties;
        var lastIndex = properties.length - 1;
        var newValues = node.properties.map(function (item, i) { return getPropertyString(source, item, multiLine, i === lastIndex); });
        var newString = newValues.join('');
        if (multiLine) {
            newString = "\n" + newString + "\n";
        }
        newString = "{" + newString + "}";
        var typeAnnotation = node.typeAnnotation;
        if (typeAnnotation) {
            newString += source.getText(typeAnnotation);
        }
        return fixer.replaceText(node, newString);
    };
}
var rule = {
    meta: {
        type: 'layout',
        fixable: 'whitespace',
        schema: {
            type: 'array',
            minItems: 0,
            maxItems: 1,
            items: {
                type: 'object',
                properties: {
                    items: {
                        type: 'number',
                        minimum: 1,
                    },
                    itemsWithRest: {
                        type: 'number',
                        minimum: 1,
                    },
                    maxLength: {
                        type: 'number',
                        minimum: 4,
                    },
                    consistent: {
                        type: 'boolean',
                    },
                    allowAllPropertiesOnSameLine: {
                        type: 'boolean',
                    },
                },
            },
        },
        messages: (_a = {},
            _a[exports.MUST_SPLIT] = "Object desctructuring lines must be broken into multiple lines if there are more than {{" + exports.MUST_SPLIT + "}} properties",
            _a[exports.MUST_SPLIT_TOO_LONG] = "Object desctructuring lines must be broken into multiple lines if the line is longer than {{" + exports.MUST_SPLIT_TOO_LONG + "}}",
            _a[exports.MUST_NOT_SPLIT] = "Object desctructuring lines must not be broken into multiple lines if there are {{" + exports.MUST_NOT_SPLIT + "}} or less elements.",
            _a[exports.NO_BLANK_BETWEEN] = 'Object desctructuring lines cannot have blank line between them.',
            _a[exports.CONSIST_NEWLINE] = 'Object desctructuring lines must be put on newlines',
            _a[exports.MULTILINE_PROPERTY] = 'Object desctructuring lines have multiline property must be put on newlines',
            _a),
    },
    create: function (ctx) {
        var _a;
        var source = ctx.getSourceCode();
        var _b = ((_a = ctx.options[0]) !== null && _a !== void 0 ? _a : {}), _c = _b.items, items = _c === void 0 ? MAX_COUNT : _c, _d = _b.itemsWithRest, itemsWithRest = _d === void 0 ? MAX_REST_COUNT : _d, _e = _b.maxLength, maxLength = _e === void 0 ? MAX_LENGTH : _e, _f = _b.consistent, consistent = _f === void 0 ? CONSISTENT : _f, _g = _b.allowAllPropertiesOnSameLine, allowAllPropertiesOnSameLine = _g === void 0 ? ALLOW_ALL_PROPERTIES_ON_SAME_LINE : _g;
        return {
            ObjectPattern: function (node) {
                var _a, _b, _c;
                var _d, _e, _f, _g;
                var properties = node.properties;
                if (properties.length <= 1) {
                    return;
                }
                var currenLoc;
                var nextLoc;
                var hasRest = false;
                var multiLine = false;
                var inSameLine = false;
                var hasBlankBetween = false;
                var hasMultilineProperty = false;
                var commentLines = [];
                var openBrace = source.getFirstToken(node, function (token) { return token.value === '{'; });
                var closeBrace = source.getLastToken(node, function (token) { return token.value === '}'; });
                source.getCommentsInside(node)
                    .forEach(function (comment) {
                    if (comment.loc) {
                        for (var i = comment.loc.start.line; i <= comment.loc.end.line; i++) {
                            commentLines.push(i);
                        }
                    }
                });
                for (var i = 0; i < properties.length - 1; i++) {
                    hasRest || (hasRest = properties[i].type === 'RestElement');
                    currenLoc = properties[i].loc;
                    nextLoc = properties[i + 1].loc;
                    if (!currenLoc || !nextLoc) {
                        continue;
                    }
                    if (currenLoc.end.line !== currenLoc.start.line) {
                        hasMultilineProperty = true;
                    }
                    if (nextLoc.start.line !== currenLoc.end.line) {
                        multiLine = true;
                    }
                    else if (nextLoc.start.line === currenLoc.end.line) {
                        inSameLine = true;
                    }
                    if (currenLoc.end.line + 1 < nextLoc.start.line) {
                        if (!hasBlankBetween) {
                            for (var j = currenLoc.end.line + 1; j < nextLoc.start.line; j++) {
                                if (!commentLines.includes(j)) {
                                    hasBlankBetween = true;
                                    break;
                                }
                            }
                        }
                        continue;
                    }
                    if (i === properties.length - 2) {
                        hasRest || (hasRest = properties[i + 1].type === 'RestElement');
                        hasMultilineProperty || (hasMultilineProperty = nextLoc.end.line !== nextLoc.start.line);
                    }
                }
                var maxCount = hasRest ? itemsWithRest : items;
                var start = (_e = (_d = node.loc) === null || _d === void 0 ? void 0 : _d.start.line) !== null && _e !== void 0 ? _e : NaN;
                var end = (_g = (_f = node.loc) === null || _f === void 0 ? void 0 : _f.end.line) !== null && _g !== void 0 ? _g : NaN;
                var lines = ctx.getSourceCode().getLines().slice(start - 1, end);
                var textLength = lines.map(function (line) { return line.trim(); }).join('').length;
                // loc is null/undefined
                if (Number.isNaN(start) && Number.isNaN(end)) {
                    return;
                }
                // line break is not included in lines
                var isLongText = (textLength + end - start) > maxLength;
                var hasManyItems = properties.length > maxCount;
                // multiline property has the greatest weight
                if (hasMultilineProperty && !multiLine) {
                    ctx.report({
                        node: node,
                        messageId: exports.MULTILINE_PROPERTY,
                    });
                    return;
                }
                // conditions that need wrap text
                if (hasManyItems || isLongText) {
                    if (!multiLine) {
                        ctx.report({
                            node: node,
                            messageId: hasManyItems ? exports.MUST_SPLIT : exports.MUST_SPLIT_TOO_LONG,
                            data: hasManyItems
                                ? (_a = {}, _a[exports.MUST_SPLIT] = maxCount.toString(), _a) : (_b = {}, _b[exports.MUST_SPLIT_TOO_LONG] = maxLength.toString(), _b),
                            fix: getFixer(source, node),
                        });
                        return;
                    }
                    if (inSameLine) {
                        ctx.report({
                            node: node,
                            messageId: exports.CONSIST_NEWLINE,
                            fix: getFixer(source, node),
                        });
                    }
                    if (hasBlankBetween) {
                        ctx.report({
                            node: node,
                            messageId: exports.NO_BLANK_BETWEEN,
                            fix: getFixer(source, node),
                        });
                    }
                    return;
                }
                if (consistent
                    && inSameLine
                    && !isSameLine(openBrace, closeBrace)
                    && !allowAllPropertiesOnSameLine) {
                    ctx.report({
                        node: node,
                        messageId: exports.CONSIST_NEWLINE,
                        fix: getFixer(source, node, false),
                    });
                    return;
                }
                if (!consistent && multiLine && !hasMultilineProperty) {
                    if (!allowAllPropertiesOnSameLine) {
                        ctx.report({
                            node: node,
                            messageId: exports.MUST_NOT_SPLIT,
                            data: (_c = {},
                                _c[exports.MUST_NOT_SPLIT] = maxCount.toString(),
                                _c),
                            fix: getFixer(source, node, false),
                        });
                    }
                    else if (inSameLine
                        || isSameLine(openBrace, source.getTokenAfter(openBrace))
                        || isSameLine(source.getTokenBefore(closeBrace), closeBrace)) {
                        ctx.report({
                            node: node,
                            messageId: exports.CONSIST_NEWLINE,
                            fix: getFixer(source, node),
                        });
                    }
                }
            },
        };
    },
};
exports.default = rule;
